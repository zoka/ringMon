<html>
  <head>
    <title>noirMon</title>
    <meta charset="utf-8">
    <script src="/js/jquery-1.7.1.min.js"></script>

    <script src="/js/codemirror.js"></script>
    <script src="/js/clojure.js"></script>
    <link rel="stylesheet" href="/css/codemirror.css">
    <style> .CodeMirror { border: 1px solid black; }</style>
  </head>

  <body>
    <button id="getmondata">Refresh Data</button>
    <input type="checkbox" id="periodic" >Periodic (2 sec)</input>
    <button id="dojvmgc" style="margin-left:25px;" >Force JVM GC</button>

    <br></br>
    <p>
        <a href="http://webnoir.org/">Noir</a> (web framework written in
        <a href="http://clojure.org/">Clojure</a>)
        server app montoring demo (raw JMX and derived data).
        Get code at
        <a href="https://github.com/zoka/noirMon/">GitHub</a>.
    </p>

    <table id="dataTree"
             border="0"
             style="margin-left:30px;"
             cellpadding="0"  cellspacing="0" width = "200px">
      <thead></thead>
      <tbody class="tdata">
      </tbody>
    </table>

    <span>nREPL output</span>
    <button id="irq" style="margin-left:25px;">Interrupt</button>
    <textarea id="ClojOut">
    </textarea>
    <span>nREPL input. Ctrl-Enter to submit the current buffer/selection.
          Ctrl-Up and Ctrl-Down to browse history.
          Ctrl-Home to clear REPL windows. Ctrl-End to clear history.</span>
    <textarea id="Cloj">
    </textarea>

    <script>

    var flagPeriodic = false;
    var lastAjaxRequestTime = 0;
    var nReplPending = false;

    var replSession="One";
    var lastCid=""; // last repl command id

    var replIn, replOut;
    var replHist = [];
    var nextHistNdx = 0;
    var ndxHist = 0;

    var annMonData = {}; // annotated JSON of monitoring data, adding __hidden: true
                         // into object data will colapse it on display


    $(document).ready(function() {
      // executed upon page load

      // button handlers
      $("#getmondata").click(clickGetMonData);
      $("#dojvmgc").click(clickDoJvmGc);
      $("#irq").click(replBreak);

      // initial refresh
      clickGetMonData();

     // periodic checkbox data refredh
      $('#periodic').on('change', function () {
        if ($(this).is(':checked')) {
          flagPeriodic = true;
          periodicGetMonData();
          $("#getmondata").attr("disabled", true);
        } else {
          flagPeriodic = false;
          $("#getmondata").attr("disabled", false);
        }
      });

      initEditor();
      $('#periodic').trigger('click'); // periodic data update on
    });


    function trim(stringToTrim) {
      return stringToTrim.replace(/^\s+|\s+$/g,"");
    }
    function ltrim(stringToTrim) {
      return stringToTrim.replace(/^\s+/,"");
    }
    function rtrim(stringToTrim) {
      return stringToTrim.replace(/\s+$/,"");
    }

    function replRefresh(){
      // same command, but empty code buffer
      // means  we just want refresh for long running repl script output
      // should not be needed when we get WebSockets
      doAjaxCmd (
        {
          cmd: "do-repl",
          code: "",
          sess: replSession
        });
    }

    function replBreak() {
      doAjaxCmd (
      {
        cmd: "repl-break",
        cid: lastCid,
        sess: replSession
      });

    }

    function replSubmit(e) {
      if (e != replIn)
        return;
      var b = e.getValue();
      var s = e.getSelection();
      b = rtrim(b);
      s = rtrim(s);
      if (b == "")
        return;     // nothing to do

      if (s == "") {
        e.setValue("");
        replHist [nextHistNdx++] = b;
        ndxHist = nextHistNdx; // history pointer past freshest item
      } else
        b = s;  // submit sellection only, no need to flush the current buffer

      doAjaxCmd (
      {
        cmd: "do-repl",
        code: b,
        sess: replSession
      });
    }

    function bufferEnd(e) {
      e.setSelection(
      {
        line:e.lineCount()-1
      }, null,!0);
    }

    function appendBuffer(e, s) {
      bufferEnd(e);
      e.replaceSelection(s);
      bufferEnd(e);
    }

    function restoreBuffer(e, b) {
      b = rtrim(b);
      e.setValue(b);
      bufferEnd(e); // restore cursor at the end of last line
    }

    function histBack(e) {
      if (e != replIn)
        return;
      if (ndxHist > 0) {
        if (ndxHist == nextHistNdx) {
          var b = e.getValue();
          b = rtrim(b);
          if (b != "") {
            // preserve current buffer if not empty
            replHist[nextHistNdx++] = b;
          }
        }
        ndxHist--;
        if (ndxHist < nextHistNdx) {
          var b = replHist[ndxHist];
          restoreBuffer(e,b);
        }
      }
    }

    function histFwd(e) {
      if (e != replIn)
        return;
      if (ndxHist < nextHistNdx) {
        ndxHist++;
        if (ndxHist < nextHistNdx) {
          var b = replHist[ndxHist];
          restoreBuffer(e,b);
        } else
          e.setValue("");
      }
    }

    function clearEditor(e) {
      if (e != replIn)
        return;
      ndxHist = nextHistNdx;
      replOut.setValue("");
      replIn.setValue("");
    }

    function clearHistory(e) {
      if (e != replIn)
        return;
      ndxHist = nextHistNdx = 0;
      replIn.setValue("");
    }

    var clojScript =

         "(loop [i 0]"
+ "\n" + '  (println \"i=\"i)'
+ "\n" + "  (Thread/sleep 1000)"
+ "\n" + "  (if (< i 10)"
+ "\n" + "    (recur (inc i))"
+ "\n" + "    i))      ; press Ctr-Enter to submit for execution"
+ "\n" + "             ; Once started, execution of this script can be "
+ "\n" + '             ; stopped by "Interrupt" button';

    function initEditor() {
      replOut = CodeMirror.fromTextArea(document.getElementById('ClojOut'),
        {
          matchBrackets: true,
          mode: "text/x-clojure",
          readOnly:true
        });

      replIn = CodeMirror.fromTextArea(document.getElementById('Cloj'),
        {
          lineNumbers: true,
          matchBrackets: true,
          mode: "text/x-clojure"
        });

      replOut.setValue("");
      replIn.setValue(clojScript);

      CodeMirror.keyMap.default["Ctrl-Enter"] = replSubmit;
      CodeMirror.keyMap.default["Ctrl-Up"]    = histBack;
      CodeMirror.keyMap.default["Ctrl-Down"]  = histFwd;
      CodeMirror.keyMap.default["Ctrl-Home"]  = clearEditor;
      CodeMirror.keyMap.default["Ctrl-End"]   = clearHistory;
    }

    function clickGetMonData() {
      doAjaxCmd(
        {
          cmd: "get-mon-data",
          sess: replSession
        });
    }

    function getMsec() {
      return new Date().getTime();
    }

    function periodicGetMonData() {
      if (nReplPending) {
        nReplPending = false;
        clickGetMonData();
        setTimeout(periodicGetMonData, 500);
        return;
      }

      if (!flagPeriodic)
        return;
      var delta = getMsec() - lastAjaxRequestTime;
      if ( delta > 2000)
        clickGetMonData();
      setTimeout(periodicGetMonData, 2000);  // issue periodic request every 2 seconds if enabled
    }

    function clickDoJvmGc() {
      $("#dojvmgc").attr("disabled", true); // disable button until GC is executed
      doAjaxCmd(
        {
          cmd: "do-jvm-gc"
        });
    }

    function replPrint(e, mode, text) {
      var cName = "";
      switch (mode) {
        case "out":
          text = rtrim(text) ;
          break;
        case "err":
          cName = "cm-error";
          text = trim(text) ;
          break;
        case "ns":
          text = trim(text) ;
          break;
        case "value":
          text = rtrim(text) ;
          cName = "cm-repl-val";
          break;
        case "code":
          text = rtrim(text);
          break;
      }

      bufferEnd(e);
      var from = e.getCursor();
      appendBuffer(e,text);
      var to = e.getCursor();

      if (cName != "") {
        e.markText(from, to, cName);
      }
      // ommit trailing newline only for ns
      if (mode != "ns")
        appendBuffer(e,"\n");
    }

    function searchVec (v, text) {
      for (i in v) {
        if (v[i] == text)
          return true;
      }
      return false;
    }

    function respDoRepl(code, jdata) {
      var s = code;
      if (code != "")
        replPrint(replOut,"code", code);

      for (obj in jdata) {
        var val = jdata[obj];
        if (!isObject (val))
          continue;
        if ("out" in val) {
          var text = val["out"];
          s += text;
          replPrint(replOut,"out", text);
        }
        if ("ns" in val) {  // ask for ns befotr value
          var text = val["ns"] +"=>";
          s += text;
          replPrint(replOut,"ns", text);
        }
        if ("value" in val) {
          var text = val["value"];
          s += text;
          replPrint(replOut,"value", text);
        }
        if ("err" in val) {
          var text = val["err"];
          s += text;
          replPrint(replOut,"err", text);
        }
        if ("status" in val) {
          var svec = val["status"];
          if (searchVec(svec,"interrupted")) {
          replPrint(replOut, "err", "Interrupted");
          } else {
            if (searchVec(svec,"interrupt-id-mismatch")) {
              replPrint(replOut, "err", "Interrupt operation failed");
            }
          }
        }
        if ("id" in val) {
            lastCid = val["id"];    // record last command id
        }
      }
      if (s != "") {
        // there was some repl output activity
        // schedule next request faster
        nReplPending = true;
      }
    }

    function doAjaxCmd(request) {
      // use inner function to be able to refer to original request in closure
      var respCallback = function ( jdata) {
        var cmd = request["cmd"];
        switch (cmd) {
          case "get-mon-data":
            jsonToTable(jdata);
            break;
          case "do-jvm-gc":
            $("#dojvmgc").attr("disabled", false); // re-enable button on cmd ack
            clickGetMonData(); // refresh monitoring data
            break;
          case "do-repl":
            respDoRepl(request["code"], jdata);
            break;
          case "repl-break":
            respDoRepl("", jdata);
        }
      }

      lastAjaxRequestTime = getMsec();
      $.ajax("/admin/moncmd",
        {
          data: request,    // JSON encoded request
          type: "GET",
          dataType: "json",
          contentType: "application/json",
          success: respCallback
        });
    }

    function isObject ( obj ) {
      return obj && (typeof obj  === "object");
    }

    // search json object jobj for the first instance of
    // object named objname and
    // then set its property named "__hidden" to val
    function annSetHidden(jobj, objname, val) {
      for (var name in jobj) {
        var v = jobj[name];
        if (isObject(v)) {
          if (name == objname) {
            v["__hidden"] = val;
            return;
          } else
            annSetHidden(v, objname,val)
        }
      }
    }

    function attachHideHandler (id) {
      $("[id="+id+"]").on("change", function(event) {
        var nameCell, name;

        nameCell = event.target.parentElement.nextSibling.nextSibling;
        name = nameCell.textContent;
        name = name.slice(0, name.length - 1); // remove ":" at the end
        if ($(this).is(':checked'))
          annSetHidden(annMonData, name, false);
        else
          annSetHidden(annMonData, name,  true);
        jsonToTable(annMonData);
      });
    }

    function makeRow(ident, name, val, hidden) {
      var s = "<tr>",
      align ,
      style ,
      vstyle,
      hChk = "",     // hide check box markup
      chkState = "",
      hdr = false,   // true for header row
      hdrPad;       // markup for padding cell to align checkboxes properly

      if (val === "")
        hdr = true;

      if (hdr) {
        align = ' align="left"';
        style = ' style="background:#F5F51D"';
        vstyle = style

        if (!hidden)
          chkState  = 'checked="yes"';
        hChk = '<input type="checkbox" id="hide"'+chkState+"></input>";
      } else {
        align = ' align="right"';
        style = ' style="background:#BAF7C3"';
        vstyle = ' style="background:#B5F2F5"';
      }

      if (hdr) {
        hdrPad = "<td"+style+"></td>";
      } else {
        hdrPad  = "";
      }

      for (var i = 0; i < ident; i++) {
          s += "<td></td>";
      }
      s += "<td>"+hChk+hdrPad+"</td><td"+align+style+">"+name+
           ":</td><td align=right"+vstyle+">"+val+"</td></tr/>";
      return s;
    }

    function makeTbl(s, jdata, ident) {
      for (var name in jdata) {
        if (name == "nREPL") {
          respDoRepl("", jdata[name]);
          continue;         // skip nREPL
        }
        var val = jdata[name];
        if (!isObject(val)) {
          if (name != "__hidden")  // do not show hidden field, it is only for internal use
            s += makeRow(ident, name, val, false);
        }  else {
          var hidden = false;
          if ("__hidden" in val)
            hidden = val["__hidden"];

          s += makeRow(ident, name, "", hidden);
          if (!hidden)
            s += makeTbl("", val, ident+1);
        }
      }
      return s;
    }

    function isEmpty(obj) {
      for(var i in obj)
        return false;
      return true;
    }


    function annotateJson(fresh, ann) {
      var init = false;
      var firstobj = false;
      if (isEmpty (ann)) {
        // initial update set all hidden except first one
        init = true;
        firstobj = true;
      }

      for (var name in fresh) {
        if (name == "nREPL") {
          ann[name]= fresh[name];
          continue;
        }
        var val = fresh[name];
        if (isObject (val)) {
          if (!(name in ann) ) {
            ann[name]= fresh[name];
            if (init) {
              if (firstobj) {
                ann[name]["__hidden"] = false;
                firstobj = false;
              } else
                ann[name]["__hidden"] = true;
            }
          } else
            annotateJson(val, ann[name]);
          } else {
          ann[name] = fresh[name]; // fresh data value
        }
      }
    }

    function jsonToTable(jdata) {
      annotateJson(jdata, annMonData); // update annotated data
                                       // preserving hidden field markers, if any
      $(".tdata").empty();
      var s= makeTbl("", annMonData, 0);
      $(".tdata").append(s);
      attachHideHandler("hide");
    }

    </script>


  </body>
</html>

